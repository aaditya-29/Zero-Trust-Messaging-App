<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Secure Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs/lib/stomp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsencrypt@3.0.0-rc.1/bin/jsencrypt.min.js"></script>
    <script src="https://openfpcdn.io/fingerprintjs/v4"></script>
    <style>
        .online {
            color: green;
        }

        .offline {
            color: red;
        }

        .typing {
            font-style: italic;
            color: orange;
        }

        .message-status {
            font-size: 0.8em;
            margin-left: 10px;
            color: gray;
        }
    </style>
</head>

<body>
    <h1>Welcome to Secure Chat</h1>

    <div>
        <label>Recipient Email:</label>
        <input type="text" id="toUser">
        <span id="userStatus"></span><br>

        <label>Message:</label>
        <input type="text" id="message" oninput="sendTypingStatus(true)" onblur="sendTypingStatus(false)"><br>

        <label>
            <input type="checkbox" id="sensitiveMode"> ðŸ”¥ Sensitive Mode
        </label><br>

        <button id="sendBtn">Send</button>
    </div>

    <div id="typingIndicator" class="typing"></div>

    <h2>Messages:</h2>
    <ul id="messageList"></ul>

    <script th:inline="javascript">
        let stompClient = null;
        const currentUserEmail = /*[[${email}]]*/ "";
        const privateKeyBase64 = /*[[${privateKey}]]*/ "";

        document.getElementById('sendBtn').addEventListener('click', sendMessage);

        function connect() {
            const socket = new SockJS('/chat-websocket');
            stompClient = Stomp.over(socket);

            stompClient.connect({}, frame => {
                console.log('Connected: ' + frame);

                stompClient.subscribe(`/topic/messages/${currentUserEmail}`, messageOutput => {
                    const message = JSON.parse(messageOutput.body);
                    decryptAndDisplayMessage(message);
                });

                stompClient.subscribe(`/topic/read-receipts/${currentUserEmail}`, receipt => {
                    const data = JSON.parse(receipt.body);
                    markMessagesAsRead(data.receiver);
                });

                stompClient.subscribe(`/topic/typing/${currentUserEmail}`, typingInfo => {
                    const data = JSON.parse(typingInfo.body);
                    document.getElementById("typingIndicator").innerText = data.typing ? `${data.sender} is typing...` : "";
                });

                stompClient.subscribe(`/topic/status/${currentUserEmail}`, statusInfo => {
                    const data = JSON.parse(statusInfo.body);
                    document.getElementById("userStatus").innerHTML =
                        data.status === "ONLINE"
                            ? "<span class='online'>Online</span>"
                            : "<span class='offline'>Offline</span>";
                });

                sendStatus(true);
            });
        }

        function generateAESKey() {
            return CryptoJS.lib.WordArray.random(32).toString();
        }

        function encryptAES(message, aesKey) {
            return CryptoJS.AES.encrypt(message, aesKey).toString();
        }

        function decryptAES(encryptedText, aesKey) {
            const bytes = CryptoJS.AES.decrypt(encryptedText, aesKey);
            return bytes.toString(CryptoJS.enc.Utf8);
        }

        function encryptRSA(data, publicKey) {
            const encryptor = new JSEncrypt();
            encryptor.setPublicKey(publicKey);
            return encryptor.encrypt(data);
        }

        function decryptRSA(encryptedData) {
            const decryptor = new JSEncrypt();
            decryptor.setPrivateKey(privateKeyBase64);
            return decryptor.decrypt(encryptedData);
        }

        function sendMessage() {
            const toUser = document.getElementById('toUser').value.trim();
            const messageText = document.getElementById('message').value.trim();
            const sensitive = document.getElementById('sensitiveMode').checked;

            if (!toUser || !messageText) {
                alert("Recipient and message cannot be empty.");
                return;
            }

            const aesKey = generateAESKey();
            const encryptedMessage = encryptAES(messageText, aesKey);

            fetch(`/api/public-key?email=${encodeURIComponent(toUser)}`)
                .then(response => response.text())
                .then(publicKey => {
                    const encryptedAESKey = encryptRSA(aesKey, publicKey);

                    stompClient.send("/app/chat", {}, JSON.stringify({
                        from: currentUserEmail,
                        to: toUser,
                        content: encryptedMessage,
                        aesKeyEncryptedWithRSA: encryptedAESKey,
                        sensitive: sensitive
                    }));

                    const listItem = document.createElement('li');
                    listItem.id = `sent-${Date.now()}`;
                    listItem.textContent = `Me: ${messageText} ${sensitive ? 'ðŸ”¥' : ''}`;

                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'message-status';
                    statusSpan.textContent = 'Delivered âœ…';

                    listItem.appendChild(statusSpan);
                    document.getElementById('messageList').appendChild(listItem);

                    document.getElementById('message').value = "";
                });
        }

        function decryptAndDisplayMessage(message) {
            const decryptedAESKey = decryptRSA(message.encryptedAESKey);
            const originalMessage = decryptAES(message.encryptedMessage, decryptedAESKey);

            const listItem = document.createElement('li');
            listItem.id = `msg-${message.id}`;

            const displayText = `${message.sender}: ${originalMessage} ${message.sensitive ? 'ðŸ”¥' : ''}`;

            const statusSpan = document.createElement('span');
            statusSpan.className = 'message-status';

            if (message.expired === true) {
                statusSpan.textContent = ' [Expired]';
            } else if (message.status === "READ") {
                statusSpan.textContent = ' âœ…âœ… (Read)';
            } else {
                statusSpan.textContent = ' âœ… (Delivered)';
            }

            listItem.textContent = displayText;
            listItem.appendChild(statusSpan);
            document.getElementById('messageList').appendChild(listItem);
        }

        function markMessagesAsRead(receiverEmail) {
            document.querySelectorAll('li').forEach(li => {
                if (li.innerText.includes(receiverEmail)) {
                    const statusSpan = li.querySelector('.message-status');
                    if (statusSpan) {
                        statusSpan.textContent = ' âœ…âœ… (Read)';
                    }
                }
            });
        }

        function loadPreviousMessages() {
            const list = document.getElementById('messageList');
            list.innerHTML = "";

            fetch(`/api/messages?email=${encodeURIComponent(currentUserEmail)}`)
                .then(response => response.json())
                .then(messages => {
                    if (messages.length === 0) {
                        const listItem = document.createElement('li');
                        listItem.textContent = "No new messages.";
                        list.appendChild(listItem);
                    } else {
                        messages.forEach(m => decryptAndDisplayMessage(m));
                    }
                })
                .catch(err => {
                    console.error("Failed to fetch messages:", err);
                });
        }

        function sendTypingStatus(isTyping) {
            const toUser = document.getElementById('toUser').value;
            if (toUser) {
                stompClient.send("/app/typing", {}, JSON.stringify({
                    sender: currentUserEmail,
                    receiver: toUser,
                    typing: isTyping
                }));
            }
        }

        function sendStatus(isOnline) {
            stompClient.send("/app/status", {}, JSON.stringify({
                userId: currentUserEmail,
                status: isOnline ? "ONLINE" : "OFFLINE"
            }));
        }

        window.addEventListener('beforeunload', () => {
            sendStatus(false);
        });

        connect();
        loadPreviousMessages();
    </script>

    <script>
        FingerprintJS.load().then(fp => {
            fp.get().then(result => {
                const visitorId = result.visitorId;
                sessionStorage.setItem('deviceId', visitorId);

                const emailInput = document.getElementById("toUser");
                if (emailInput) {
                    fetch('/api/device-fingerprint', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: emailInput.value, deviceId: visitorId })
                    });
                }
            });
        });
    </script>
</body>

</html>